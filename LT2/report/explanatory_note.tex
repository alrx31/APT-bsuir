% !TeX program = xelatex
% Пояснительная записка для лабораторной работы №1.
% Компиляция: xelatex -shell-escape explanatory_note.tex
\documentclass[variant=labwork]{bsuir}
\usepackage{graphicx}
\usepackage{float}
\usepackage{fvextra}
\DefineVerbatimEnvironment{code}{Verbatim}{breaklines=true,breakanywhere=true,fontsize=\fontsize{10pt}{12pt}\selectfont}
\sloppy
\setlength{\emergencystretch}{2em}
\faculty{Компьютерного проектирования}
\departmentlong{Инжинерной психологии и эргономики}
\departmentshort{ИПиЭ}
\manager{Василькова А.Н.}
\worktitle{Activity: работа с элементами экрана, обработка нажатий кнопок}
\workcode{1}
\titlepageyear{2025}
\titleright{}
\titleleft{}
\group{310901}
\student{Усов А.М.}
\coursename{Технологии программирования приложений}

\begin{document}
\maketitle
\mainmatter

В рамках данной лабораторной работы разрабатывается приложение Calculator для платформы Android. Приложение представляет собой калькулятор с базовыми математическими операциями и функциями памяти.

\textbf{Цель работы} — формирование у студентов знаний и навыков работы с элементами экрана, обработки нажатий кнопок в Android-приложениях.

Скриншоты графических представлений приложения Calculator

\section{Вертикальная ориентация экрана}

Ниже представлен внешний вид приложения Calculator в вертикальной ориентации экрана в Android Studio.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{screenshots/portrait.png}
\caption{Графическое представление приложения Calculator в вертикальной ориентации}
\label{fig:portrait}
\end{figure}

На рисунке \ref{fig:portrait} показан интерфейс приложения Calculator в вертикальной ориентации экрана.

\section{Горизонтальная ориентация экрана}

Ниже представлен внешний вид приложения Calculator в горизонтальной ориентации экрана в Android Studio.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{screenshots/landscape.jpg}
\caption{Графическое представление приложения Calculator в горизонтальной ориентации}
\label{fig:landscape}
\end{figure}

На рисунке \ref{fig:landscape} показан интерфейс приложения Calculator в горизонтальной ориентации экрана.

Код Activity приложения Calculator

\textbf{1. Что такое нативное мобильное приложение, мобильная платформа?}

Нативное мобильное приложение — это приложение, разработанное специально для конкретной мобильной платформы (Android, iOS) с использованием языков программирования и инструментов разработки, предоставляемых этой платформой. Нативные приложения имеют прямой доступ к API операционной системы и аппаратным возможностям устройства, что обеспечивает высокую производительность и полную интеграцию с платформой.

Мобильная платформа — это операционная система и набор инструментов разработки для мобильных устройств. Основные мобильные платформы: Android (Google), iOS (Apple), Windows Mobile (Microsoft).

\textbf{2. Что собой представляет архитектура мобильной платформы Android?}

Архитектура Android построена на основе Linux-ядра и состоит из нескольких уровней:
\begin{itemize}
    \item \textbf{Linux Kernel} — нижний уровень, обеспечивающий работу драйверов устройств, управление памятью и процессами;
    \item \textbf{Hardware Abstraction Layer (HAL)} — уровень абстракции аппаратного обеспечения;
    \item \textbf{Native Libraries} — библиотеки на C/C++, включая SQLite, WebKit, OpenGL;
    \item \textbf{Android Runtime (ART)} — виртуальная машина для выполнения приложений;
    \item \textbf{Application Framework} — набор API для разработчиков (Activity Manager, Content Providers, View System и др.);
    \item \textbf{Applications} — уровень приложений пользователя.
\end{itemize}

\textbf{3. Какие основные компоненты Android-приложения Вы знаете?}

Основные компоненты Android-приложения:
\begin{itemize}
    \item \textbf{Activity} — компонент, представляющий один экран с пользовательским интерфейсом;
    \item \textbf{Service} — компонент для выполнения длительных операций в фоновом режиме;
    \item \textbf{BroadcastReceiver} — компонент для обработки системных и пользовательских широковещательных сообщений;
    \item \textbf{ContentProvider} — компонент для управления доступом к структурированным данным приложения;
    \item \textbf{Fragment} — переиспользуемая часть пользовательского интерфейса внутри Activity.
\end{itemize}

\textbf{4. Что собой представляет структура Android-проекта? Что содержит файл конфигурации AndroidManifest.xml, папка java, папка res?}

Структура Android-проекта включает:
\begin{itemize}
    \item \textbf{AndroidManifest.xml} — файл конфигурации, содержащий информацию о приложении: название, иконки, разрешения, объявление компонентов (Activity, Service и др.), минимальную и целевую версии Android SDK;
    \item \textbf{папка java/} — содержит исходный код приложения на Java/Kotlin, организованный по пакетам;
    \item \textbf{папка res/} — содержит ресурсы приложения: layouts (XML-разметки), drawable (изображения, иконки), values (строки, цвета, стили), mipmap (иконки приложения), menu (меню) и др.
\end{itemize}

\textbf{5. Что такое графическое представление Activity?}

Графическое представление Activity — это пользовательский интерфейс, отображаемый на экране устройства. Оно создается с помощью XML-разметки (layout files) или декларативно с помощью Jetpack Compose. Графическое представление включает различные UI-элементы (View): кнопки, текстовые поля, изображения и др., организованные в контейнеры (Layout).

\textbf{6. Что такое Layout? Какие существуют виды Layout?}

Layout (макет) — это контейнер, определяющий структуру и расположение дочерних элементов интерфейса. Основные виды Layout:
\begin{itemize}
    \item \textbf{LinearLayout} — располагает элементы линейно (вертикально или горизонтально);
    \item \textbf{RelativeLayout} — позволяет позиционировать элементы относительно друг друга;
    \item \textbf{ConstraintLayout} — гибкий layout с ограничениями для позиционирования;
    \item \textbf{FrameLayout} — простой контейнер, накладывающий элементы друг на друга;
    \item \textbf{GridLayout} — располагает элементы в виде сетки;
    \item \textbf{TableLayout} — организует элементы в виде таблицы.
\end{itemize}

В Jetpack Compose используются аналогичные компоновки: \texttt{Column}, \texttt{Row}, \texttt{Box}, \texttt{ConstraintLayout}.

\textbf{7. Какие параметры (атрибуты) имеют View-элементы?}

Основные атрибуты View-элементов:
\begin{itemize}
    \item \textbf{android:id} — уникальный идентификатор элемента;
    \item \textbf{android:layout\_width} и \textbf{android:layout\_height} — размеры элемента (match\_parent, wrap\_content, конкретные значения);
    \item \textbf{android:layout\_margin} — внешние отступы;
    \item \textbf{android:padding} — внутренние отступы;
    \item \textbf{android:gravity} — выравнивание содержимого внутри элемента;
    \item \textbf{android:text} — текст элемента;
    \item \textbf{android:textSize} — размер текста;
    \item \textbf{android:background} — фоновый цвет или изображение;
    \item \textbf{android:visibility} — видимость элемента;
    \item \textbf{android:enabled} — доступность элемента для взаимодействия.
\end{itemize}

\textbf{8. Как создать Layout-файл для работы в горизонтальной ориентации экрана мобильного устройства? В каких случаях это необходимо?}

Для создания Layout-файла для горизонтальной ориентации необходимо:
\begin{itemize}
    \item создать папку \texttt{res/layout-land/} в проекте;
    \item разместить в ней XML-файл с тем же именем, что и для вертикальной ориентации (например, \texttt{activity\_main.xml});
    \item в файле использовать горизонтальную ориентацию (\texttt{android:orientation="horizontal"}) или другую компоновку, оптимизированную для широкого экрана.
\end{itemize}

Это необходимо в случаях, когда:
\begin{itemize}
    \item требуется различное расположение элементов в разных ориентациях;
    \item нужно использовать дополнительное пространство экрана в горизонтальной ориентации;
    \item требуется оптимизация интерфейса под различные размеры экрана.
\end{itemize}

В Jetpack Compose адаптация к ориентации выполняется программно через проверку \texttt{LocalConfiguration.current} и условное построение UI.

\textbf{9. Для чего нужны методы setContentView, findViewById?}

\begin{itemize}
    \item \textbf{setContentView()} — метод Activity, устанавливающий XML-разметку или Compose контент в качестве пользовательского интерфейса Activity. В традиционном подходе принимает ID ресурса layout: \texttt{setContentView(R.layout.activity\_main)}. В Compose используется \texttt{setContent \{ ... \}} для установки Compose UI.
    \item \textbf{findViewById()} — метод для поиска View-элемента по его ID в XML-разметке. Возвращает ссылку на элемент для дальнейшей работы с ним (изменение текста, установка обработчиков событий и т.д.). В Compose этот метод не используется, так как элементы создаются декларативно и доступны напрямую в коде.
\end{itemize}

\textbf{10. Какие существуют способы обработки событий в Activity?}

Основные способы обработки событий:
\begin{itemize}
    \item \textbf{Анонимные классы} — создание объекта, реализующего интерфейс слушателя (например, \texttt{OnClickListener}) непосредственно в коде;
    \item \textbf{Именованные классы} — создание отдельного класса, реализующего интерфейс слушателя;
    \item \textbf{Реализация интерфейса в Activity} — Activity реализует интерфейс слушателя напрямую;
    \item \textbf{Lambda-выражения} — использование лямбда-функций для обработки событий (современный подход в Kotlin);
    \item \textbf{Ссылки на методы} — использование ссылок на методы через оператор \texttt{::}.
\end{itemize}

В Jetpack Compose обработка событий выполняется через функции-обработчики, передаваемые в качестве параметров в Composable функции (например, \texttt{onClick = \{ /* код */ \}}).


Код Activity приложения Calculator

Ниже представлен код файла \texttt{MainActivity.kt}, содержащий логику обработки нажатий кнопок и вычислений с использованием Jetpack Compose:

\begin{code}
package com.example.lt1

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            LT1Theme {
                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
                    CalculatorScreen(
                        modifier = Modifier.padding(innerPadding)
                    )
                }
            }
        }
    }
}

@Composable
fun CalculatorScreen(modifier: Modifier = Modifier) {
    var displayValue by remember { mutableStateOf("0") }
    var previousValue by remember { mutableStateOf(0.0) }
    var operation by remember { mutableStateOf<Char?>(null) }
    var waitingForNewValue by remember { mutableStateOf(false) }
    var errorMessage by remember { mutableStateOf<String?>(null) }
    var memoryValue by remember { mutableStateOf(0.0) }
    var hasMemory by remember { mutableStateOf(false) }
    var history by remember { mutableStateOf<List<String>>(emptyList()) }
    
    val configuration = LocalConfiguration.current
    val isLandscape = configuration.screenWidthDp > configuration.screenHeightDp

    fun formatResult(result: Double): String {
        return if (result % 1.0 == 0.0) {
            result.toInt().toString()
        } else {
            String.format("%.10f", result).trimEnd('0').trimEnd('.')
        }
    }

    fun handleNumberInput(number: String) {
        if (errorMessage != null) {
            errorMessage = null
        }
        if (waitingForNewValue) {
            displayValue = number
            waitingForNewValue = false
        } else {
            displayValue = if (displayValue == "0" || displayValue == "Ошибка: деление на 0") {
                number
            } else {
                displayValue + number
            }
        }
    }

    fun handleOperation(op: Char) {
        if (errorMessage != null) {
            return
        }
        val currentValue = displayValue.toDoubleOrNull() ?: 0.0
        
        if (operation != null && !waitingForNewValue) {
            val result = when (operation) {
                '+' -> previousValue + currentValue
                '-' -> previousValue - currentValue
                '*' -> previousValue * currentValue
                '/' -> if (currentValue != 0.0) previousValue / currentValue else Double.NaN
                else -> currentValue
            }
            
            if (result.isNaN()) {
                displayValue = "Ошибка: деление на 0"
                errorMessage = "Ошибка: деление на 0"
                previousValue = 0.0
                operation = null
                waitingForNewValue = true
                return
            }
            
            displayValue = formatResult(result)
            previousValue = result
        } else {
            previousValue = currentValue
        }
        
        operation = op
        waitingForNewValue = true
    }

    fun handleEquals() {
        if (errorMessage != null || operation == null) {
            return
        }
        val currentValue = displayValue.toDoubleOrNull() ?: 0.0
        val operationSymbol = when (operation) {
            '+' -> "+"
            '-' -> "-"
            '*' -> "×"
            '/' -> "÷"
            else -> ""
        }
        val result = when (operation) {
            '+' -> previousValue + currentValue
            '-' -> previousValue - currentValue
            '*' -> previousValue * currentValue
            '/' -> if (currentValue != 0.0) previousValue / currentValue else Double.NaN
            else -> currentValue
        }
        
        if (result.isNaN()) {
            displayValue = "Ошибка: деление на 0"
            errorMessage = "Ошибка: деление на 0"
            history = history + "${formatResult(previousValue)} $operationSymbol ${formatResult(currentValue)} = Ошибка"
        } else {
            val formattedResult = formatResult(result)
            displayValue = formattedResult
            history = history + "${formatResult(previousValue)} $operationSymbol ${formatResult(currentValue)} = $formattedResult"
            if (history.size > 10) {
                history = history.takeLast(10)
            }
        }
        previousValue = 0.0
        operation = null
        waitingForNewValue = true
    }

    fun handleClear() {
        displayValue = "0"
        previousValue = 0.0
        operation = null
        waitingForNewValue = false
        errorMessage = null
    }

    fun handleBackspace() {
        if (errorMessage != null) {
            return
        }
        if (displayValue.length > 1 && displayValue != "0") {
            displayValue = displayValue.dropLast(1)
        } else {
            displayValue = "0"
        }
    }

    fun handleDecimalPoint() {
        if (errorMessage != null) {
            errorMessage = null
            displayValue = "0."
            waitingForNewValue = false
            return
        }
        if (waitingForNewValue) {
            displayValue = "0."
            waitingForNewValue = false
        } else if (!displayValue.contains(".")) {
            displayValue += "."
        }
    }

    fun handleSignChange() {
        if (errorMessage != null) {
            return
        }
        val currentValue = displayValue.toDoubleOrNull()
        if (currentValue != null) {
            displayValue = if (currentValue == 0.0) {
                "0"
            } else if (displayValue.startsWith("-")) {
                displayValue.substring(1)
            } else {
                "-$displayValue"
            }
        }
    }

    // Адаптивная компоновка в зависимости от ориентации
    if (isLandscape) {
        Row(
            modifier = modifier
                .fillMaxSize()
                .background(MaterialTheme.colorScheme.background)
                .padding(6.dp),
            horizontalArrangement = Arrangement.spacedBy(6.dp)
        ) {
            Column(modifier = Modifier.weight(1f)) {
                // История вычислений
                Surface(
                    modifier = Modifier
                        .fillMaxWidth()
                        .weight(1f),
                    shape = RoundedCornerShape(16.dp),
                    color = MaterialTheme.colorScheme.surfaceVariant
                ) {
                    if (history.isEmpty()) {
                        Box(
                            modifier = Modifier.fillMaxSize(),
                            contentAlignment = Alignment.Center
                        ) {
                            Text("История вычислений", fontSize = 16.sp)
                        }
                    } else {
                        LazyColumn(
                            modifier = Modifier.fillMaxSize().padding(8.dp),
                            reverseLayout = true
                        ) {
                            items(history.reversed()) { item ->
                                Text(item, fontSize = 14.sp, modifier = Modifier.padding(vertical = 4.dp))
                            }
                        }
                    }
                }
                Spacer(modifier = Modifier.height(6.dp))
                // Дисплей
                Surface(
                    modifier = Modifier.fillMaxWidth().height(120.dp),
                    shape = RoundedCornerShape(16.dp),
                    color = MaterialTheme.colorScheme.surface
                ) {
                    Box(modifier = Modifier.fillMaxSize().padding(16.dp)) {
                        Text(
                            text = displayValue,
                            fontSize = if (errorMessage != null) 24.sp else 48.sp,
                            fontWeight = FontWeight.Bold,
                            textAlign = TextAlign.End,
                            modifier = Modifier.align(Alignment.TopEnd)
                        )
                    }
                }
            }
            // Кнопки калькулятора
            CalculatorNumpad(
                modifier = Modifier.weight(1f),
                onNumberClick = { handleNumberInput(it) },
                onOperationClick = { handleOperation(it) },
                onEqualsClick = { handleEquals() },
                onClearClick = { handleClear() },
                onBackspaceClick = { handleBackspace() },
                onDecimalClick = { handleDecimalPoint() },
                onSignClick = { handleSignChange() }
            )
        }
    } else {
        Column(
            modifier = modifier
                .fillMaxSize()
                .background(MaterialTheme.colorScheme.background)
                .padding(6.dp)
        ) {
            // История вычислений
            Surface(
                modifier = Modifier.fillMaxWidth().weight(1f).heightIn(min = 100.dp),
                shape = RoundedCornerShape(16.dp),
                color = MaterialTheme.colorScheme.surfaceVariant
            ) {
                LazyColumn(
                    modifier = Modifier.fillMaxSize().padding(8.dp),
                    reverseLayout = true
                ) {
                    items(history.reversed()) { item ->
                        Text(item, fontSize = 14.sp, modifier = Modifier.padding(vertical = 4.dp))
                    }
                }
            }
            Spacer(modifier = Modifier.height(6.dp))
            // Дисплей и кнопки
            Column(modifier = Modifier.fillMaxWidth()) {
                Surface(
                    modifier = Modifier.fillMaxWidth().height(100.dp),
                    shape = RoundedCornerShape(16.dp),
                    color = MaterialTheme.colorScheme.surface
                ) {
                    Box(modifier = Modifier.fillMaxSize().padding(16.dp)) {
                        Text(
                            text = displayValue,
                            fontSize = if (errorMessage != null) 24.sp else 48.sp,
                            fontWeight = FontWeight.Bold,
                            textAlign = TextAlign.End,
                            modifier = Modifier.align(Alignment.TopEnd)
                        )
                    }
                }
                Spacer(modifier = Modifier.height(6.dp))
                CalculatorNumpad(
                    modifier = Modifier.fillMaxWidth(),
                    onNumberClick = { handleNumberInput(it) },
                    onOperationClick = { handleOperation(it) },
                    onEqualsClick = { handleEquals() },
                    onClearClick = { handleClear() },
                    onBackspaceClick = { handleBackspace() },
                    onDecimalClick = { handleDecimalPoint() },
                    onSignClick = { handleSignChange() }
                )
            }
        }
    }
}

@Composable
fun CalculatorNumpad(
    onNumberClick: (String) -> Unit,
    onOperationClick: (Char) -> Unit,
    onEqualsClick: () -> Unit,
    onClearClick: () -> Unit,
    onBackspaceClick: () -> Unit,
    onDecimalClick: () -> Unit,
    onSignClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier,
        verticalArrangement = Arrangement.spacedBy(6.dp)
    ) {
        // Строки кнопок с цифрами и операциями
        Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(6.dp)) {
            CalculatorButton(text = "1", modifier = Modifier.weight(1f)) { onNumberClick("1") }
            CalculatorButton(text = "2", modifier = Modifier.weight(1f)) { onNumberClick("2") }
            CalculatorButton(text = "3", modifier = Modifier.weight(1f)) { onNumberClick("3") }
            CalculatorButton(text = "+", modifier = Modifier.weight(1f), backgroundColor = MaterialTheme.colorScheme.primaryContainer) { onOperationClick('+') }
        }
        // ... остальные строки кнопок аналогично
    }
}

@Composable
fun CalculatorButton(
    text: String,
    modifier: Modifier = Modifier,
    backgroundColor: Color = MaterialTheme.colorScheme.surfaceVariant,
    textColor: Color = MaterialTheme.colorScheme.onSurfaceVariant,
    onClick: () -> Unit
) {
    Surface(
        modifier = modifier
            .height(50.dp)
            .clip(RoundedCornerShape(10.dp))
            .clickable { onClick() },
        color = backgroundColor
    ) {
        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            Text(text, fontSize = 18.sp, fontWeight = FontWeight.Medium, color = textColor)
        }
    }
}
\end{code}

В классе \texttt{MainActivity} реализована логика калькулятора с использованием Jetpack Compose:
\begin{itemize}
    \item использование \texttt{ComponentActivity} и функции \texttt{setContent()} для установки Compose UI;
    \item создание адаптивного интерфейса, который автоматически изменяется в зависимости от ориентации экрана;
    \item использование состояния через \texttt{remember} и \texttt{mutableStateOf} для управления данными калькулятора;
    \item обработка нажатий кнопок через функции-обработчики, передаваемые в Compose компоненты;
    \item реализация логики вычислений с поддержкой основных математических операций и функций памяти.
\end{itemize}

Интерфейс приложения создается декларативно с помощью Compose компонентов, что позволяет легко адаптировать его под различные ориентации экрана без использования XML-разметки.

Заключение

В ходе выполнения лабораторной работы было разработано Android-приложение Calculator, реализующее базовые математические операции. Приложение поддерживает вертикальную и горизонтальную ориентации экрана, используя Jetpack Compose для создания адаптивного интерфейса.

Были изучены и применены следующие технологии и подходы:
\begin{itemize}
    \item создание пользовательского интерфейса с использованием Jetpack Compose;
    \item работа с Compose компонентами (\texttt{Column}, \texttt{Row}, \texttt{Surface}, \texttt{Text});
    \item обработка событий нажатий кнопок через функции-обработчики в Compose;
    \item реализация логики калькулятора с поддержкой основных математических операций;
    \item использование состояния через \texttt{remember} и \texttt{mutableStateOf} для управления данными.
\end{itemize}

Приложение успешно обрабатывает нажатия кнопок и выполняет вычисления, демонстрируя навыки работы с элементами экрана и обработки пользовательского ввода в Android-приложениях с использованием современных технологий разработки.

Ответы на контрольные вопросы

\textbf{1. Что такое нативное мобильное приложение, мобильная платформа?}

Нативное мобильное приложение — это приложение, разработанное специально для конкретной мобильной платформы (Android, iOS) с использованием языков программирования и инструментов разработки, предоставляемых этой платформой. Нативные приложения имеют прямой доступ к API операционной системы и аппаратным возможностям устройства, что обеспечивает высокую производительность и полную интеграцию с платформой.

Мобильная платформа — это операционная система и набор инструментов разработки для мобильных устройств. Основные мобильные платформы: Android (Google), iOS (Apple), Windows Mobile (Microsoft).

\textbf{2. Что собой представляет архитектура мобильной платформы Android?}

Архитектура Android построена на основе Linux-ядра и состоит из нескольких уровней:
\begin{itemize}
    \item \textbf{Linux Kernel} — нижний уровень, обеспечивающий работу драйверов устройств, управление памятью и процессами;
    \item \textbf{Hardware Abstraction Layer (HAL)} — уровень абстракции аппаратного обеспечения;
    \item \textbf{Native Libraries} — библиотеки на C/C++, включая SQLite, WebKit, OpenGL;
    \item \textbf{Android Runtime (ART)} — виртуальная машина для выполнения приложений;
    \item \textbf{Application Framework} — набор API для разработчиков (Activity Manager, Content Providers, View System и др.);
    \item \textbf{Applications} — уровень приложений пользователя.
\end{itemize}

\textbf{3. Какие основные компоненты Android-приложения Вы знаете?}

Основные компоненты Android-приложения:
\begin{itemize}
    \item \textbf{Activity} — компонент, представляющий один экран с пользовательским интерфейсом;
    \item \textbf{Service} — компонент для выполнения длительных операций в фоновом режиме;
    \item \textbf{BroadcastReceiver} — компонент для обработки системных и пользовательских широковещательных сообщений;
    \item \textbf{ContentProvider} — компонент для управления доступом к структурированным данным приложения;
    \item \textbf{Fragment} — переиспользуемая часть пользовательского интерфейса внутри Activity.
\end{itemize}

\textbf{4. Что собой представляет структура Android-проекта? Что содержит файл конфигурации AndroidManifest.xml, папка java, папка res?}

Структура Android-проекта включает:
\begin{itemize}
    \item \textbf{AndroidManifest.xml} — файл конфигурации, содержащий информацию о приложении: название, иконки, разрешения, объявление компонентов (Activity, Service и др.), минимальную и целевую версии Android SDK;
    \item \textbf{папка java/} — содержит исходный код приложения на Java/Kotlin, организованный по пакетам;
    \item \textbf{папка res/} — содержит ресурсы приложения: layouts (XML-разметки), drawable (изображения, иконки), values (строки, цвета, стили), mipmap (иконки приложения), menu (меню) и др.
\end{itemize}

\textbf{5. Что такое графическое представление Activity?}

Графическое представление Activity — это пользовательский интерфейс, отображаемый на экране устройства. Оно создается с помощью XML-разметки (layout files) или декларативно с помощью Jetpack Compose. Графическое представление включает различные UI-элементы (View): кнопки, текстовые поля, изображения и др., организованные в контейнеры (Layout).

\textbf{6. Что такое Layout? Какие существуют виды Layout?}

Layout (макет) — это контейнер, определяющий структуру и расположение дочерних элементов интерфейса. Основные виды Layout:
\begin{itemize}
    \item \textbf{LinearLayout} — располагает элементы линейно (вертикально или горизонтально);
    \item \textbf{RelativeLayout} — позволяет позиционировать элементы относительно друг друга;
    \item \textbf{ConstraintLayout} — гибкий layout с ограничениями для позиционирования;
    \item \textbf{FrameLayout} — простой контейнер, накладывающий элементы друг на друга;
    \item \textbf{GridLayout} — располагает элементы в виде сетки;
    \item \textbf{TableLayout} — организует элементы в виде таблицы.
\end{itemize}

В Jetpack Compose используются аналогичные компоновки: \texttt{Column}, \texttt{Row}, \texttt{Box}, \texttt{ConstraintLayout}.

\textbf{7. Какие параметры (атрибуты) имеют View-элементы?}

Основные атрибуты View-элементов:
\begin{itemize}
    \item \textbf{android:id} — уникальный идентификатор элемента;
    \item \textbf{android:layout\_width} и \textbf{android:layout\_height} — размеры элемента (match\_parent, wrap\_content, конкретные значения);
    \item \textbf{android:layout\_margin} — внешние отступы;
    \item \textbf{android:padding} — внутренние отступы;
    \item \textbf{android:gravity} — выравнивание содержимого внутри элемента;
    \item \textbf{android:text} — текст элемента;
    \item \textbf{android:textSize} — размер текста;
    \item \textbf{android:background} — фоновый цвет или изображение;
    \item \textbf{android:visibility} — видимость элемента;
    \item \textbf{android:enabled} — доступность элемента для взаимодействия.
\end{itemize}

\textbf{8. Как создать Layout-файл для работы в горизонтальной ориентации экрана мобильного устройства? В каких случаях это необходимо?}

Для создания Layout-файла для горизонтальной ориентации необходимо:
\begin{itemize}
    \item создать папку \texttt{res/layout-land/} в проекте;
    \item разместить в ней XML-файл с тем же именем, что и для вертикальной ориентации (например, \texttt{activity\_main.xml});
    \item в файле использовать горизонтальную ориентацию (\texttt{android:orientation="horizontal"}) или другую компоновку, оптимизированную для широкого экрана.
\end{itemize}

Это необходимо в случаях, когда:
\begin{itemize}
    \item требуется различное расположение элементов в разных ориентациях;
    \item нужно использовать дополнительное пространство экрана в горизонтальной ориентации;
    \item требуется оптимизация интерфейса под различные размеры экрана.
\end{itemize}

В Jetpack Compose адаптация к ориентации выполняется программно через проверку \texttt{LocalConfiguration.current} и условное построение UI.

\textbf{9. Для чего нужны методы setContentView, findViewById?}

\begin{itemize}
    \item \textbf{setContentView()} — метод Activity, устанавливающий XML-разметку или Compose контент в качестве пользовательского интерфейса Activity. В традиционном подходе принимает ID ресурса layout: \texttt{setContentView(R.layout.activity\_main)}. В Compose используется \texttt{setContent \{ ... \}} для установки Compose UI.
    \item \textbf{findViewById()} — метод для поиска View-элемента по его ID в XML-разметке. Возвращает ссылку на элемент для дальнейшей работы с ним (изменение текста, установка обработчиков событий и т.д.). В Compose этот метод не используется, так как элементы создаются декларативно и доступны напрямую в коде.
\end{itemize}

\textbf{10. Какие существуют способы обработки событий в Activity?}

Основные способы обработки событий:
\begin{itemize}
    \item \textbf{Анонимные классы} — создание объекта, реализующего интерфейс слушателя (например, \texttt{OnClickListener}) непосредственно в коде;
    \item \textbf{Именованные классы} — создание отдельного класса, реализующего интерфейс слушателя;
    \item \textbf{Реализация интерфейса в Activity} — Activity реализует интерфейс слушателя напрямую;
    \item \textbf{Lambda-выражения} — использование лямбда-функций для обработки событий (современный подход в Kotlin);
    \item \textbf{Ссылки на методы} — использование ссылок на методы через оператор \texttt{::}.
\end{itemize}

В Jetpack Compose обработка событий выполняется через функции-обработчики, передаваемые в качестве параметров в Composable функции (например, \texttt{onClick = \{ /* код */ \}}).

\end{document}
